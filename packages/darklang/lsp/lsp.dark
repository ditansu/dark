module Darklang =
  module LanguageServerProtocol =
    /// A tagging type for string properties that are actually document URIs.
    type DocumentUri = String

    /// A tagging type for string properties that are actually URIs
    type URI = String

    type Position = { line: Int; character: Int }

    type Range = { start: Position; ``end``: Position }

    /// Represents a location inside a resource, such as a line inside a text file
    type Location = { uri: DocumentUri; range: Range }

    // -- done with base types --

    // <Diagnostics>

    /// "Warning" | "Error"
    type DiagnosticSeverity = String

    type Diagnostic =
      { severity: DiagnosticSeverity
        range: Range
        message: String }

    type ComputeDiagnosticsInput =
      { uri: String
        text: String
        maxNumberOfProblems: Int }

    type ComputeDiagnosticsOutput = { diagnostics: List<Diagnostic> }

    let getDiagnostics (input: String) : String =
      // let input =
      //   (Builtin.Json.parse<ComputeDiagnosticsInput> input) |> Builtin.unwrap

      match Builtin.LanguageTools.parseCliScript input with
      | Ok() ->
        (ComputeDiagnosticsOutput { diagnostics = [] })
        |> Builtin.Json.serialize<ComputeDiagnosticsOutput>

      | Error parseError ->
        let start = Position { line = 0; character = 0 }

        let end' =
          let lines = input |> Stdlib.String.split "\n"

          Position
            { line = (Stdlib.List.length lines) - 1
              character =
                lines |> Stdlib.List.last |> Builtin.unwrap |> Stdlib.String.length }

        let diagnostics =
          [ Diagnostic
              { severity = "Error"
                range = Range { start = start; ``end`` = end' }
                message =
                  "Can't parse (and can't yet report on specific area of failure)\n"
                  ++ parseError } ]

        (ComputeDiagnosticsOutput { diagnostics = diagnostics })
        |> Builtin.Json.serialize<ComputeDiagnosticsOutput>

// </Diagnostics>